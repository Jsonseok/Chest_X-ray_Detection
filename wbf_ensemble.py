# -*- coding: utf-8 -*-
"""WBF Ensemble.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rnyBYIv6hJVwQ34NRXlPQx92WVF_HhEU
"""



!pip install -U ensemble-boxes

import pandas as pd
import numpy as np
from ensemble_boxes import *
from glob import glob
import copy
from tqdm import tqdm
import shutil
import zipfile
import os

height_dict

height_dict = pd.read_csv('/content/drive/MyDrive/test_vinbig.csv').to_dict('records')
fnl_dict ={}
for ix,i in enumerate(height_dict):
    fnl_dict[i['image_id']] = [i['width'],i['height'],i['width'],i['height']]

height_dict

fnl_dict

xlsx_list = [file for file in os.listdir('/content') if file.endswith('csv')]
xlsx_list

#합칠 파일 
subs = [pd.read_csv(i) for i in xlsx_list]
pred_2cls = pd.read_csv('/content/drive/MyDrive/2-cls test pred.csv')

pred_2cls

def submission_decoder(df:pd.DataFrame) -> np.ndarray:
    info = df.values
    df_lst = []
    for i in info:
        pre_lst = i[1].split(' ')
        if(pre_lst[-1] == ''):
            pre_lst = pre_lst[:-1]
        for j in range(0,len(pre_lst),6):
            df_lst.append([i[0],int(pre_lst[j]),float(pre_lst[j+1]),int(float(pre_lst[j+2])),int(float(pre_lst[j+3])),\
                           int(float(pre_lst[j+4])),int(float(pre_lst[j+5])),fnl_dict.get(i[0])[0],fnl_dict.get(i[0])[1]])
    return pd.DataFrame(df_lst,columns = ['image_id','class_id','score','x_min','y_min','x_max','y_max','width','height'])

subs = [submission_decoder(subs[i]) for i in range(len(subs))]

subs[0]

subs[0]

boxes_dict = {}
scores_dict = {}
labels_dict = {}
whwh_dict = {}

for i in tqdm(subs[0].image_id.unique()):
    if not i in boxes_dict.keys():
        boxes_dict[i] = []
        scores_dict[i] = []
        labels_dict[i] = []
        whwh_dict[i] = []

    size_ratio = fnl_dict.get(i)
    whwh_dict[i].append(size_ratio) 
    tmp_df = [subs[x][subs[x]['image_id']==i] for x in range(len(subs))]
    
    for x in range(len(tmp_df)):
        boxes_dict[i].append(((tmp_df[x][['x_min','y_min','x_max','y_max']].values)/size_ratio).tolist())
        scores_dict[i].append(tmp_df[x]['score'].values.tolist())
        labels_dict[i].append(tmp_df[x]['class_id'].values.tolist())

weights = [1]*1
#n = 1
#n=넣는 파일 갯수 -1(*n)
# 현재 2개를 합지기 때문에1
weights += [3]
weights1 = [3,2,4,5]
iou_thr = 0.25
skip_box_thr = 0.0
sigma = 0.1

fnl = {}

for i in tqdm(boxes_dict.keys()):
    
    
    boxes, scores, labels = weighted_boxes_fusion(boxes_dict[i], scores_dict[i], labels_dict[i],\
                                                  weights=weights, iou_thr=iou_thr, skip_box_thr=skip_box_thr)
    
    
    if not i in fnl.keys():
        fnl[i] = {'boxes':[],'scores':[],'labels':[]}
        
    fnl[i]['boxes'] = boxes*whwh_dict[i]
    fnl[i]['scores'] = scores
    fnl[i]['labels'] = labels

pd_form = []
for i in fnl.keys():
    b = fnl[i]
    for j in range(len(b['boxes'])):
        try:
          pd_form.append([i,int(b['labels'][j]),round(b['scores'][j],2),\
                          int(b['boxes'][j][0]),int(b['boxes'][j][1]),\
                          int(b['boxes'][j][2]),int(b['boxes'][j][3])])
        except:
          pd_form.append([i,14 ,1.0, 0 ,0 ,1 ,1])
        
final_df = pd.DataFrame(pd_form,columns = ['image_id','class_id','score','x_min','y_min','x_max','y_max'])
final_df = final_df.drop_duplicates(keep = 'first')

def submission_encoder(df:pd.DataFrame) -> np.ndarray:
    dct = {}
    for i in tqdm(df['image_id'].unique()):
        if not i in dct.keys():
            dct[i] = []
        tmp = df[df['image_id'] == i].values
        for j in tmp:
            dct[i].append(int(j[1]))
            dct[i].append(float(j[2]))
            dct[i].append(int(j[3]))
            dct[i].append(int(j[4]))
            dct[i].append(int(j[5]))
            dct[i].append(int(j[6]))
        
        dct[i] = map(str,dct[i])
        dct[i] = ' '.join(dct[i])
    dct = [[k, v] for k, v in dct.items()]
    return pd.DataFrame(dct,columns = ['image_id','PredictionString']).reset_index(drop = True)

df = submission_encoder(final_df)
df.to_csv('Fold5Yolo.csv', index=False)



NORMAL = "14 1 0 0 1 1"
low_threshold = 0.00
high_threshold = 0.99
pred_det_df = df  # You can load from another submission.csv here too.
n_normal_before = len(pred_det_df.query("PredictionString == @NORMAL"))
merged_df = pd.merge(pred_det_df, pred_2cls, on="image_id", how="left")

if "target" in merged_df.columns:
    merged_df["class0"] = 1 - merged_df["target"]

c0, c1, c2 = 0, 0, 0
for i in range(len(merged_df)):
    p0 = merged_df.loc[i, "class0"]
    if p0 < low_threshold:
        # Keep, do nothing.
        c0 += 1
    elif low_threshold <= p0 and p0 < high_threshold:
        # Add, keep "det" preds and add normal pred.
        if ' 14 ' not in merged_df.loc[i, "PredictionString"]:
            merged_df.loc[i, "PredictionString"] += f" 14 {p0} 0 0 1 1"
            
        c1 += 1
    else:
        # Replace, remove all "det" preds.
        merged_df.loc[i, "PredictionString"] = NORMAL
        c2 += 1

n_normal_after = len(merged_df.query("PredictionString == @NORMAL"))
print(
    f"n_normal: {n_normal_before} -> {n_normal_after} with threshold {low_threshold} & {high_threshold}"
)
print(f"Keep {c0} Add {c1} Replace {c2}")
submission_filepath = str("WBF_ensemble.csv")
submission_df = merged_df[["image_id", "PredictionString"]]
submission_df.to_csv(submission_filepath, index=False)
print(f"Saved to {submission_filepath}")

from google.colab import files
files.download(f'/content/WBF_ensemble.csv')